---
title: "Model Diagnostics"
author: "Jared"
date: "12/7/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r prep, include = F}
library(monocle3)
library(ggplot2)
library(tidyr)
library(tibble)
library(dplyr)
library(MASS)
library(Polychrome)
source("/home/jared/projects/projection_drivers/ENS/scripts/accessory_functions/fitHelper.R")
source("/home/jared/ENS/Timecourse_ENS/scripts/accessory_functions/pattern_plotting.R")

```


```{r loadin, echo=F}
# Load in required datsets and pweights --------------------------
#dataset to project into.
lmmp <- readRDS("/home/jared/ENS/Timecourse_ENS/TC_LMMP.rds")
#lmmp <- lmmp[fData(lmmp)$num_cells_expressed > 5,]
lmmp
genes_to_use <- rownames(lmmp)
#Remove any patterns learned on this dataset so we don't get confused
previous.pattern.ind <- stringr::str_detect(colnames(pData(lmmp)), pattern = "Pattern")
pData(lmmp) <- pData(lmmp)[,!previous.pattern.ind]

#Previously learned gene weights from NMF on logscaled expression counts
learned_weights <- read.csv(file = "/home/jared/ENS/6mo_LMMP/results/NMF/lmmp/lmmp_6mo_11-1_pattern_gene_weights.csv",
                            row.names = 1)
npattern <- dim(learned_weights)[2]



load.existing.projection.values <- 1

if(load.existing.projection.values){
  #first column is cell barcodes, rest of columns are patterns
  transferred_cell_wts <- read.csv("/home/jared/projects/projection_drivers/ENS/results/TC_LMMP_in_6mo_LMMP_11-25_patterns.csv", row.names = 1)
}else{
  set.seed(539)
  target_cell_wts_list <- lapply(1:npattern, function(i){
    wts <- as.matrix(learned_weights[,paste0("cellPattern",i), drop = F])
    target_cell_wts <- t(projectR::projectR(data = as.matrix(log10(exprs(lmmp)+1)),
                                            loadings = as.matrix(wts)))
  })
  
  transferred_cell_wts <- do.call(cbind, target_cell_wts_list)
  colnames(transferred_cell_wts) = paste0("cellPattern",1:npattern)
  transferred_cell_wts <- as.data.frame(transferred_cell_wts) %>% rownames_to_column(var = "cell_barcode")
  
  #write.csv(transferred_cell_wts,"/home/jared/projects/projection_drivers/ENS/results/TC_LMMP_in_6mo_LMMP_11-25_patterns.csv", quote = F)}
}

#Bind pattern weights to object
pData(lmmp) <- cbind(pData(lmmp), transferred_cell_wts)




learned_weights <- as.data.frame(learned_weights) %>% rownames_to_column(var = "gene_id")
learned_weights <- learned_weights[learned_weights[,"gene_id"] %in% genes_to_use,]


```

```{r fit_models}
# Model fittings ----
#Change these parameters:
genes_of_interest <- c("Hbb-bs", "Hba-a1","Hba-a2", "Malat1")
pattern_of_interest <- c(37) #RBC 
plotCellPatterns(pattern_of_interest, lmmp, do.clip = c(0,.98))


genes <- c(fData(lmmp)$gene_short_name[1:1], genes_of_interest)
lmmp_sub <- lmmp[fData(lmmp)$gene_short_name %in% genes,]

model_str <- paste0("~0 + cell_type*cellPattern",pattern_of_interest)
exp_family <- "negbinomial"
ncores = min(length(genes), 16)

system.time(glm_models <- fit_models(cds = lmmp_sub, model_formula_str = model_str, expression_family = exp_family, cores = ncores,
                                     clean_model = F, verbose = T))

#TODO: if a model fails, make sure the genes are labelled appropriately
extracted_models <- unlist(as.list(glm_models[,"model"]), recursive = F)
names(extracted_models) <- genes

#Execute outside of monocle framework
do.manual.fit <- 0
if(do.manual.fit){
  glm.nb.out.list <- lapply(genes, fitHelper, lmmp, model_str)
  names(glm.nb.out.list) <- genes
  
  
  #Reverses the nesting, gives two main heading lists (result and error) which each have a list (or NULL) for every gene
  glm.nb.out.list <- glm.nb.out.list %>% purrr::transpose()
  
  #Either NULL or a successful model, full model returned from glm.nb()
  successful_models <- pluck(glm.nb.out.list, "result")
  
  #either NULL or an error message from glm.nb()
  failed_models_msg <- pluck(glm.nb.out.list, "error")
}
```

```{r}
gene_key <- as.data.frame(fData(lmmp)[,c("gene_id","gene_short_name")])

exprs_mat <- as.matrix(exprs(lmmp[fData(lmmp)$gene_short_name %in% genes_of_interest,]))
for(i in 1:length(genes_of_interest)){
  matched_gene_id <- gene_key[,"gene_id"][which(gene_key[,"gene_short_name"] == genes_of_interest[i])]
  rownames(exprs_mat)[rownames(exprs_mat) == matched_gene_id] <- genes_of_interest[i]
}
colors <- glasbey.colors(22)
names(colors) <- NULL

lapply(genes_of_interest, function(gene){
  
 
    #TODO: should this be log10 or ln? Depends on link function
    data <- data.frame(log_expression = log(exprs_mat[gene,]+1),
                         log_pweights=log(transferred_cell_wts[,paste0("cellPattern",pattern_of_interest)]+1),
                                    cell_type = pData(lmmp)[,"cell_type"])
      
    #Plot cell P weights vs gene expression
    print(pl <- ggplot(data) +
            geom_point(aes(x = log_pweights, y= log_expression, color = cell_type)) + 
            scale_color_manual(values = colors)+
            ggtitle(paste0("Expression vs P weights for ", gene, " and pattern", pattern_of_interest)) +
            geom_rug(aes(x = log_pweights, y= log_expression),col= "steel blue",alpha= 0.05))

})
```

```{r resids}

#TODO: Add axis and titles
gene <- "Hbb-bs"
mod.glm <- extracted_models[[gene]]

resid_raw <- residuals.glm(mod.glm)
resid_std <- rstandard(mod.glm)
resid_part <- residuals.glm(mod.glm, type= "partial")
var(resid_std)

#weights are (mostly) one so I think these should be similar
#variance is not one, as it is suggested it should be
plot(resid_raw, resid_std)

#just curious
plot(resid_raw, resid_part[,paste0("cellPattern",pattern_of_interest)])


#aiming for complete linearity
scatter.smooth(resid_std ~ transferred_cell_wts[,paste0("cellPattern",pattern_of_interest)], col = "grey",
               main = "standardized residuals against p-weight (continuous explanatory value)", xlab = "Projected p-weights" )

#maybe modify for interaction or glm
#termplot(mod.glm, partial.resid = T, terms = paste0("cellPattern",pattern_of_interest), las=1)

plot(resid_std ~ fitted(mod.glm), col= "grey", xlim = c(0,quantile(fitted(mod.glm), .999)))
scatter.smooth(resid_std ~ fitted(mod.glm), col= "grey", xlim = c(0,quantile(fitted(mod.glm), .999)), ylim= c(-10,5))

##QQ plot for residuals, check normally distributed
qqnorm(resid_std)
qqline(resid_std)
plot(density(resid_std))
plot(density(transferred_cell_wts[,"cellPattern37"]), main = "distribution of cell pattern weights")

plot(density(log10(exprs_mat[gene,]+1)), xlim = quantile(log10(exprs_mat[gene,]+1), c(0,.99)), main = paste0("Distribution of log10 expression of ", gene))

#leverages
plot(hatvalues(mod.glm))





```


